{"version":3,"sources":["raw_phase_data_handler.js"],"names":[],"mappings":"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","file":"raw_phase_data_handler.js","sourcesContent":["((activityStatistics) => {\n    const { util } = activityStatistics;\n    const indexedForEach = R.addIndex(R.forEach);\n\n    // converts event bus messages to domain events\n    // keeps track of the raw data to handle changes to data\n    activityStatistics.RawPhaseDataHandler = () => {\n        const rawData = { header: [], rows: [] };\n        // maps indexes of original data to indexes of data for a specific user\n        const indexMap = [];\n        const lastIndexForUser = {};\n\n        let initializedUsers = Immutable.Set();\n\n        return {\n            handle(message) {\n                if (message.sessionControllerResultType === 'initTable') {\n                    return handleInitMessage(message);\n                }\n                if (message.sessionControllerResultType === 'deltaLogs') {\n                    return handleDeltaMessage(message);\n                }\n            },\n        };\n\n        function handleInitMessage(message) {\n            rawData.header = message.header;\n            if (!message.rows) return undefined;\n            rawData.rows = message.rows;\n\n            return R.pipe(\n                indexedForEach((d, index) => d.originalIndex = index),\n                R.groupBy((d) => d.username),\n                R.toPairs(),\n                R.map(([username, activities]) => {\n                    initializedUsers = initializedUsers.add(username);\n                    setIndexes(username, activities);\n                    return initialPhaseEvent(username, activities);\n                })\n            )(util.eventBus.mapHeadersToRows(message));\n        }\n\n        function handleDeltaMessage(message) {\n            if (!message.logs) return undefined;\n            const log = message.logs[0];\n            if (!log) return undefined;\n            if (log.actionName === 'appendRow') {\n                return handleAppendRow(log);\n            }\n            if (log.actionName === 'changeCell') {\n                return handleChangeCell(log);\n            }\n        }\n\n        function handleChangeCell(data) {\n            const affectedRow = rawData.rows[data.rowIndex];\n            const affectedHeader = rawData.header[data.columnIndex];\n            affectedRow[data.columnIndex] = data.newValue;\n            let value = data.newValue;\n            if (affectedHeader.dataType === 'zonedDateTime') {\n                value = new Date(value);\n            }\n            return {\n                name: 'phase_activity_changed',\n                data: {\n                    username: affectedRow[0],\n                    property: affectedHeader.title.toLowerCase(),\n                    activityIndex: indexMap[data.rowIndex],\n                    value,\n                }\n            };\n        }\n\n        function handleAppendRow(data) {\n            rawData.rows[data.index] = data.values;\n            const activity = util.eventBus.mapHeadersToRows({\n                header: rawData.header,\n                rows: [data.values],\n            })[0];\n            activity.originalIndex = data.index;\n            setIndexes(activity.username, [activity]);\n\n            if (userAlreadyInitialized(activity.username)) {\n                return {\n                    name: 'phase_activity_added',\n                    data: {\n                        username: activity.username,\n                        activity\n                    },\n                };\n            }\n\n            return initialPhaseEvent(activity.username, [activity]);\n        }\n\n        function userAlreadyInitialized(username) {\n            return initializedUsers.includes(username);\n        }\n\n        function initialPhaseEvent(username, activities) {\n            initializedUsers = initializedUsers.add(username);\n            return {\n                name: 'initial_phase_activities',\n                data: { username, activities },\n            };\n        }\n\n        function setIndexes(username, activities) {\n            if (lastIndexForUser[username] === undefined) {\n                lastIndexForUser[username] = 0;\n            }\n            R.forEach((activity) => {\n                indexMap[activity.originalIndex] = lastIndexForUser[username];\n                lastIndexForUser[username]++;\n            }, activities);\n        }\n    };\n})(golab.tools.activityStatistics);\n"],"sourceRoot":"/source/"}